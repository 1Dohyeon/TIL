### 18.1 CSR, SSR 차이

**CSR(Client Side Rendering)** 은 말 그대로 클라이언트에서 웹 페이지가 렌더링됨. 서버에서 클라이언트로 html, css, js를 모두 보내기 때문에 첫 렌더링은 오래걸림, 다른 페이지로 이동할 때는 이미 html이 있어서 빠름.

**SSR(Server Side Rendering)** 은 반대로 서버에서 렌더링을 하기 때문에 첫 페이지 접근이 상대적으로 더 빠름. 하지만 다른 페이지로 이동 시에 CSR보다 느림.

### 18.2 MVC 패턴

**MVC** (모델-뷰-컨트롤러) 는 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴이다. 소프트웨어의 비즈니스 로직과 화면을 구분하는데 중점을 두는 패턴이며, 이러한 "관심사 분리" 는 더나은 업무의 분리와 향상된 관리를 제공한다. 

MVC 소프트웨어 디자인 패턴의 세 가지 부분은 다음과 같이 설명할 수 있다 :
1. Model: 데이터와 비즈니스 로직을 관리합니다.
2. View: 레이아웃과 화면을 처리합니다.
3. Controller: 모델과 뷰로 명령을 전달합니다.

### 18.3 소켓 프로그래밍

WebSocket(ws) 이란 http 프로토콜과 같이 프로토콜의 일종이며, 클라이언트와 서버(브라우저와 서버)를 연결하고 언제든 양방향(주고 받는) 통신 또는 데이터 전송이 가능하도록 하는 기술이다.

http 프로토콜 GET/POST 방식에서는 request가 오면 응답을 하는 단방향 방식이었다. 하지만 어느 웹앱에서는 request가 오지 않아도 꾸준히 데이터 갱신을 할 필요가 있는 서비스가 존재할 것이다. 예를 들어 주식 차트 등...

아무튼 이런 실시간 웹앱을 위해서는 클라이언트와 서버가 양방향으로 연결되어 요청이 없어도 꾸준히 응답을 해줄 필요가 있다. 이때 프로그램은 ms 단위로 계속 웹앱을 갱신할 수 있다. 하지만 이런 방식이면 서버는 과부화가 걸리게 된다.

이런 상황에서 유용하게 쓰이는 방법이 바로 WebSocket 방식이다. 소켓은 아래와 같은 방식으로 엔드포인트를 연결한다.

``` ts
const socket = io('/chattings');
```

소켓을 통해서 데이터를 전달하고 받을 때는 다음과 같은 메서드를 이용한다

``` ts
// 전달
socket.emit()
socket.broadcast.emit('new_chat', {
  chat,
  username: socketObj.username,
});

// 받음
socket.on('new_chat', (data) => {
  const { chat, username } = data;
  drawNewChat(`${username}: ${chat}`);
});
```

코드 전체는 [이곳](https://github.com/1Dohyeon/Study-NestJS/blob/main/05_project2/src/chats/chats.gateway.ts)에서 확인 가능하다. 코드 내의 기능은 무시하고 `emit, on`에 대해서 설명하자면, `on()` 메서드의 첫번째 매개변수를 통해서 `emit`과 연동할 수 있다. 또한 받은 데이터를 실시간으로 다룬다.

`emit()`도 마찬가지로 첫번째 매개변수를 통해서 `on`과 연동하여 다음 데이터를 보낸다. `broadcast.emit()`은 말 그대로 데이터 갱신을 모든 클라우드에서 동일하게 일어나게 한다고 보면 된다. 

주식에서 누군가 매수, 매도를 하면 수량 변화는 모든 사용자에게 일정하게 나타난다. 이러한 상황처럼 실시간으로 모두의 정보를 변화시킬 필요가 있을때 `broadcast` 를 사용한다.

`'new_chat'` 와 같이 이벤트로 서로가 연결된다는 것이 특징이다.
